# Linux の教科書学習

Chapter9 まで、ComputeEngine に CentOS を入れて実施ずみ

## プロセスとは？

Linux で様々なコマンドがあったがコマンドの実態は Linux の Disk に保存されているファイルである。シェルからコマンドを実行すると、Linux カーネルは Disk から実行ファイルを読み出してメモリへ格納し、そのメモリ内容に従って CPU がプログラムを実行している。そのメモリ上で実行状態にあるプログラムのことをまさに**プロセス**という。(Linux カーネルからみた処理の単位を指す。)

プロセスは同一のコマンドが実行されても、別々のメモリ領域を持っている。

ls コマンドが 3 つ同時に実行されてもそれら 3 つのプロセスが内部に持つデータが互いに混ざるということはない。

これは Linux カーネルが 1 つ 1 つのプロセスにプロセス ID という一意の番号を割り振り、Linux カーネルがそれらを管理している。

<ローカル PC で実行した例>

```jsx
$ ps

28904 ttys000    0:00.12 /bin/zsh -il
28911 ttys001    0:00.08 /bin/zsh -il
28942 ttys002    0:00.08 /bin/zsh -il
28991 ttys003    0:00.01 /bin/zsh -il
28994 ttys004    0:00.08 /bin/zsh -il
29064 ttys005    0:00.00 /bin/zsh -il
29138 ttys006    0:00.00 /bin/zsh -il
29176 ttys007    0:00.00 /bin/zsh -il
```

また Linux でプロセスが新しく作られるときは無から作られるのではなく、すでに存在している別プロセスを元に作成されるモデルになっている。これを親子関係で表現し、作成するプロセスを親プロセス、作成されるプロセスを子プロセスという。シェルで ls コマンドを実行する場合、シェルが親プロセス、ls コマンドのプロセスが子プロセスに相当する。プロセス ID(PID)はプロセスが起動して終了するまで変化しないため、PID でプロセスを特定することが可能である。

自分のプロセスだけでなく、システムで動いているすべてのプロセスを表示するには a オプションを付加する。

```jsx
ps ax
```

上記をまとめると、Linux 環境ではマルチタスク機能によって様々なプロセスが同時に動作しているということがわかる。

## ジョブ

プロセスは Linux カーネルからみた処理の単位である。一方でシェルからみた処理の単位をジョブという。(どういうこと？全然違いがわからん。)シェルのコマンドラインに入力されている 1 つの行が 1 つのジョブに相当するようだ。つまり、コマンドを 1 つだけ実行するような場合はプロセスとジョブは 1:1 の関係になる。コマンドをパイプ(|)で繋いだような場合には繋いだ分のコマンド数がプロセス数にはなるがそれに対してジョブは 1 となる。

下記は３プロセス、1 ジョブとなる。

```jsx
$ ls -l / | cat -n | less
```

シェルの機能を用いると、ジョブを一時停止させたり、バックグラウンドで実行させたりといったジョブ制御が可能となる。

### コマンドを一時停止する

Ctrl + z でジョブの停止が可能である。

jobs コマンドでジョブの一覧を確認可能である。

#### fg コマンド ジョブをフォアグラウンドにする

一旦停止したジョブを再度確認したい(ユーザーが対話的に操作できる状態に戻したい)場合は下記のコマンドを実行する。そのような状態をフォアグラウンドと呼び、フォアグラウンドにするともいう。

```jsx
$ fg %<ジョブ番号>
```

```jsx
下記の　+　はカレントジョブを指している。
fgでジョブ番号を指定しない場合は、+のカレントジョブへ戻る。

~ ❯❯❯ jobs                                                                                                                                                 ✘ 146
[1]  + suspended  man bash
[2]  - suspended  man bash
```

## ジョブをバックグラウンドにする

Ctrl + z でジョブを停止するとそのジョブは動作を止めてしまう。このために cp file1 file2 とやった直後などに Ctrl + z を実行するとコピー処理は停止してしまい、いつまで経っても完了しないといったことなどが発生する。

このような場合に処理を続行したままシェルへ戻るようにコマンドを実行できると便利である。ユーザーが対話的に操作できないジョブの状態をバックグラウンドと呼ぶ。ジョブをバックグラウンドにするには 下記を実行する。

```jsx
$ bg %<ジョブ番号>
```

わざわざ bg コマンドを使用せずとも、下記でそもそもバックグラウンド実行が可能となる。

```jsx
$ cp file1 file2 &
```

## ジョブ・プロセスの終了

### ジョブの終了

ジョブを終了させる場合はフォアグランドジョブを実行中の場合にはキーボード入力待ちの状態となっているため、終了するために Ctrl + c を押下する。多くのプログラムは Ctrl + c を押下することで終了するように設計されている。

一方でバックグラウンドジョブの場合はキーボードの入力を受け付けていないので、Ctrl + c とはならず、kill コマンドを使用する。

```jsx
$ kill ％<ジョブ番号>
```

### プロセスの終了

プロセスを終了するにはバックグラウンドジョブの終了と同様に kill コマンドを使用する。

```jsx
$ kill <プロセスID>
```

### kill コマンド- シグナルを送信する

kill コマンドは厳密にいえばプロセスを終了させるコマンドではなく、シグナルを送信するコマンドである。シグナルとはその名の通り、プロセスに送信される信号を指す。プロセスは受け取ったシグナルの種類によって終了、停止、再起動などの様々な振る舞いをする。このように実行中のプロセスに対してシグナルを送ることでプロセス間の通信を実現している。kill コマンドによって送信されるシグナルの種類は 下記の形で指定が可能である。

```jsx
kill -<シグナル名>
```

シグナル名を省略すると、デフォルト値として TERM というシグナルを送信する。

下記の意味は同じである。

kill 4695

kill -TERM 4695

```jsx
シグナルの種類

~/d/TIL ❯❯❯  kill -l
HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM URG STOP
TSTP CONT CHLD TTIN TTOU IO XCPU XFSZ VTALRM PROF WINCH INFO USR1 USR2
```

# Chapter 11 標準入出力とパイプライン

Linux には多くのコマンドが用意されており、1 つ 1 つはできる限り小さくシンプルな動作をするように設計されている。これはコマンドにあれもこれもと機能を詰め込みすぎるよりも、1 つのコマンドは 1 つの機能を提供することに徹して単純にした方がわかりやすく使いやすいためである。Linux で様々な処理を実行するためにはこれらの小さなコマンドを連携させる仕組みが必要であり、**リダイレクトやパイプライン**が用いられている。

## 標準入力、標準出力、標準エラー出力

コマンドを連携するやり方以前に、コマンド間で情報をやり取りする仕組みを理解する必要がある。標準入出力という言葉について理解したい。

Linux では cat などのコマンドが起動されると自動的に標準的な入出力チャネルが開かれる。チャネルは水路、経路という意味になるがデータの流れる道と理解しよう。

標準入力(stdin):プログラムの標準的な入力である。キーボードが通常使用される。

標準出力(stdout):プログラムの標準的な出力で通常は端末ディスプレイが使用される。

標準エラー出力(stderr):プログラムのエラーメッセージを出力するための標準的な出力で端末ディスプレイが使用される。

3 つを合わせて、標準入出力と呼ぶ。

これらの標準入出力について入力はキーボードが通常であるがファイルでもいいし、出力は端末ディスプレイと言っているがこれもファイルやプリンタでも問題はない。

この標準入出力を実際にどこへ繋ぐかはユーザーが自由に設定でき、その標準入出力を制御する機能のことを**リダイレクト**という。

## リダイレクト

```jsx
$ cat
Hello
Hello
^C

$
```

これは cat コマンドが標準入力の内容を入力として読み込んで、それを標準出力にそのま出力するという動きをするからである。標準入力は通常キーボードなのでキーボードの値がそのまま出力された。

キーボードの代わりに標準入力をファイルに変更してみる。→ 入力リダイレクト

```jsx
$ cat < /etc/crontab
```

とやると/etc/crontab の内容が標準入力として cat コマンドへ渡され、標準出力にその内容が出力される。

標準出力と標準エラー出力をまとめる

```jsx
ls /xxxx > result.txt > 2>&1
```

Linux の内部では標準入力が 0、標準出力が 1、標準エラー出力が 2 のようにチャネル管理されている。

### リダイレクトによる上書き

下記のように echo > と記載すると、標準出力リダイレクトの際に同じファイル名であると内容が上書きされてしまうので注意すること。

> の代わりに、>>を使用することでファイル末尾に記載することができる。

```jsx
echo 123  > number.txt

echo 456  > number.txt

cat number.txt

456
```

### パイプライン

複数のコマンドを連携させるためにはあるコマンドの結果を別のコマンドで利用するための仕組みが必要である。

Linux ではコマンドの標準出力を別のコマンドの標準入力に繋ぐ”パイプライン”という機能でコマンドに連携することができる。

### フィルタ

ここまでの cat コマンドのように Linux には標準入力を入力として受け取り、標準出力に出力するコマンドが多くある。このようなコマンドをフィルタという。

Linux には他にもフィルタコマンドがいくつも用意されている。

```jsx
cat: 入力をそのまま出力する;
head: 先頭の部分を表示する;
tail: 末尾の部分を表示する;
grep: 指定した検索パターンに一致する行だけを表示する;
sort: 順番に並べ替える;
uniq: 重複した行を取り除く;
tac: 逆順に出力する;
wc: 行数やバイト数を出力する;
```

### wc コマンド

```jsx
行数を表示できる;
wc - l / etc / passwd;

単語数を表示できる;
wc - w / etc / passwd;

バイト数を表示できる;
w - c / etc / passwd;
```

### sed コマンド

非対話式のエディタである。

処理

- シェルから編集のためのコマンドを引数にして sed コマンドを実行する
- sed コマンドは編集対象のテキストに対して与えられた編集コマンドに対応する編集操作を行う
- 編集後のテキストを sed コマンドが標準出力に出力する

### sed コマンドの形式

```jsx
sed 1,5d sample.txt

1,5⇨アドレス
d⇨コマンド
```

## シェルスクリプトについて
