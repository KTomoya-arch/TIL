- Linux とは何か？
  単に Linux というと Linux カーネル、Linux ディストリビューションを指す
  基本的には Linux OS の意味で使われる
  OS の 1 つである
  OS の中核である Linux カーネルはオープンソースで開発されており、安定性も高いため、サーバー用 OS として使用されている

- OS とは何か？
  コンピューターを動作させる中核となるソフトウェアファイル群のこと
  OS が提供するものはデスクトップ環境、ファイルシステム、ネットワーク通信、プロセス間通信、プロセス・メモリ・デバイスの管理、シェル、コマンド
  OS の中核にはカーネルというソフトウェアが存在する

- Linux カーネルとは何か？
  Linux において OS の中核となるソフトウェアのことを指す
  プロセス管理、メモリ管理、デバイス管理などを行う
  OS の一部の機能を担っている

- 相対パスと絶対パス
  絶対パスは変わらないのと、長くなること、ルートディレクトリから常に辿るため、環境に依存しやすい。
  相対パスはカレントディレクトリをわかっていないといけないが短くて済む

- ターミナル , プロンプト、コマンドライン、
  ターミナルを通じ、コマンドラインにコマンドを入力してシェルというソフトウェアへ命令を伝えている
  シェルはユーザーのコマンドを解釈して実行するソフトウェアのこと。

- どういう流れか
  ls を入力するとシェルが ls という名前のコマンドに対応するファイルを linux から探す
  そして linux カーネルに実行させる(ls ファイルを渡す)
  シェルはその結果を受け取り、ターミナルへ出力している

### デバイスドライバ

Linux からハードウェアを利用するためにはデバイスドライバというものが必要である。
デバイス固有のデバイスドライバというものもあるが Linux システムに最初から搭載されている汎用のドライバ(クラスドライバ)というものも存在する。

- HID(human interface device)<br>
  キーボード、マウス

- マスストレージデバイス<br>
  USB メモリ、オーディオ、ハードディスクドライブなど

- オーディオ<br>
  マイク、スピーカーなど

- ACM Communitaton Device class<br>
  モデム、TA(ターミナルアダプタ)など

### udev

ホットプラグデバイスを接続した際にデバイスファイルを動的に作成する仕組みのことをいう。
ホットプラグデバイスはコンピュータに接続・切断を行う際に電源を切ることなくデバイスの追加・取り外しを行えるデバイスのことである。
例えば、USB デバイス、キーボード、メモリ、HDD、SDD のようなストレージデバイスのことをさす。

### shutdown コマンド

shutdown コマンドは、-k,-c,-r,-h のオプションを共ないつつシステムの停止や再起動を行うものである。
-k は、シャットダウンは行わず、ログイン中の全ユーザにメッセージの送信を行う。
-c は、実行中のシャットダウンをキャンセルする。
-h は、システムを停止する。(-halt)
-r は、システムを再起動する。

reboot というコマンドも存在し、システムの再起動を行うことができるが時間やメッセージの指定はできない。

### システムを再起動させるためには？

- ランレベルを 6 に設定する
  init 6 や telinit 6 を実行し、ランレベルを 6 にすることでシステムが再起動する。

- shutdown コマンド(上述)を使用する

- reboot コマンドを使用する

### SysVinit Upstart systemd

一般的な OS がどのように起動されるかというと下記のような手順で起動される。
電源を入れる ⇨BIOS/UEFI が起動する ⇨ ブートローダの読み込み ⇨ カーネル読み込み ⇨ 初期プロセス(init//systemd)の実行 ⇨ ログイン画面表示

初期プロセスである部分は登場した時系列で並べると、1988 年台に SysVinit、2006 年に Upstart、2011 年に systemd となる。
最近の Linux ディストリビューションの ver では systemd が主流とはなっているがまだまだ SysVinit が使用されているものも存在する。

#### SysVinit

init プロセスとして/etc/inittab に記述されたプロセスを順番に起動する。
前のプロセスの終了を待って次のプロセスを起動することからいずれかのプロセスの終了までに時間がかかるとと後続が遅れることとなり、
結果として最終的な起動までに時間がかかるというデメリットもあった。そのため、この後に Upstart や systemd のような新しい仕組みが採用されることになった。

- init プロセスを開始
- /etc/inittab ファイルを読み込む
  - システムの初期化スクリプトを実行する(/etc/rd.c/rc.sysinit Script)
  - rc スクリプトの実行(/etc/rc.d/rc Script)

inittab の書式
`id:runlevel:action:process`

```
  ①デフォルトのランレベルを設定
  ②システム初期化のためにランレベルに関係なく実行する処理 /etc/rc.d/rc.sysinit Script
  ③ランレベルに応じた処理 /etc/rc.d/rc.5
```

#### Upstart

Upstart もはじめに init プロセスが実行される。
SysVinit とは異なり、プロセスが並列で起動することにより短時間で起動することが可能になっている。
/etc/inittab ファイルは存在しない。

Upstart は`イベント駆動型`であり、デバイスの追加やネットワークの変更などのイベントを検知し
そのイベントに対応するジョブを実行する。
ジョブ・・・デーモンのような常駐型のサービスと一回きりの処理で終了するタスクからなら複数のプロセスを 1 つの処理単位としている。

起動時の流れは下記のようになる

- init プロセスの開始
- 各ジョブが待機状態になる
- システム起動イベントが発行される
- イベントに対応するジョブが並列で実行される

#### systemd

sytemd は Upstart に近く、ユニット(プロセス)を並列起動する仕組みである。

- upstart より高速
- 高速起動が可能
- システム管理がディストリビューション間で共通だったりする
  上記のことから、現在の主流になっている。

systemd ではシステム起動の処理を、Unit という単位で管理する。

systemd では init プロセスではなく、systemd プロセスが起動して、サービスを管理する。
systemd プロセスが起動すると、`default.target`という Unit が起動される。
これは/etc/systemd/system 以下に置かれたシンボリックリンクで、graphical.target などのランレベルに対応するファイルが実体としてある。

##### Unit

- target<br>
  複数のユニットをグループ化する際に使用する
- service
  プロセスの開始・停止・自動起動といった管理を行う
  default.target という Unit が起動される、/etc/systemd/system に置かれたシンボリックリンクである

### wall コマンド

システムの停止作業系を行うと多数のユーザーに影響する恐れがあるため、ログイン中の全ユーザーにメッセージを送信するという
wall というコマンドがあり、`wall [message]`で送信可能である。

### dmesg

Linux 起動時から syslog デーモンが起動するまでは syslog による/var/log/messages に出力ができないため、カーネルはログを退避用のメモリに記録する。
この退避用メモリをリングバッファと呼ぶ。このリングバッファの内容を出力するのが dmesg であり、古い順に削除されていく。

### acpid

ACPI やデーモンってなんだ？

#### ACPI

パソコンの電源管理に関する規格である。
パソコンの電源を切る際に、電源ボタンを押して切るということはあまりないと思われる。
では具体的にどのように電源を切るかというと、
shutdown などのコマンドを通じてソフトウェアがハードウェアに対して命令を伝達し、ハードウェアの電源が切れるといったルートをたどる。
この電源管理に関する決まり事を ACPI と呼ぶ。

#### デーモン

デーモンはメモリ上でお仕事が来るのを待っていて、その仕事を終えると待機状態に戻る。

話を戻すと、そのシャットダウンの命令などのイベントを受け取るのが`acpid`デーモンであり、それを伝達する。

### レスキューモード

何らかの原因で Linux が起動できない場合にインストール CD から Linux を起動する方法があり、それをレスキューモードと呼ぶ。
Linux が起動できない場合というのはルートファイルシステムの読み込みができないとか MBR が壊れた場合などである。

### modprobe
